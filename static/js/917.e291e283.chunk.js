"use strict";(self.webpackChunkreact_admin_web=self.webpackChunkreact_admin_web||[]).push([[917],{77917:function(r,n,e){e.r(n),n.default='# 字典管理\r\n这不是一个功能页面，而是本系统对字典的一种管理方式的描述及使用方式。关于这方面我思考了很久，最终还是采用在前端管理的方式。\r\n\r\n## 在 `@/utils/dict.js` 中统一管理\r\n\r\n```js\r\n// @/tuils/dict.js\r\nconst createDict = function (dict) {\r\n  return {\r\n    enum: Object.fromEntries(dict.map(({ alias, value }) => [alias, value])),\r\n    options: dict.map(({ label, value, color }) => ({ label, value, color })),\r\n    map: Object.fromEntries(dict.map((item) => [item.value, item])),\r\n  };\r\n};\r\n\r\n// 菜单类型\r\nexport const menuType = createDict([\r\n  { label: "菜单", value: "1", alias: "menu", color: "#87d068" },\r\n  { label: "目录", value: "2", alias: "folder", color: "#108ee9" },\r\n]);\r\n\r\n// 性别\r\nexport const gender = createDict([\r\n  { label: "男", value: "1", alias: "male", color: "#00b9ff" },\r\n  { label: "女", value: "2", alias: "woman", color: "#f179b4" },\r\n]);\r\n\r\n// 用户启用状态\r\nexport const accountEnabledState = createDict([\r\n  { label: "启用", value: "1", alias: "enabled", color: "#52c41a" },\r\n  {\r\n    label: "禁用",\r\n    value: "0",\r\n    alias: "disabled",\r\n    color: "rgba(30, 41, 59, 0.25)",\r\n  },\r\n]);\r\n\r\n// 角色启用状态\r\nexport const roleEnabledState = createDict([\r\n  { label: "启用", value: "1", alias: "enabled", color: "#52c41a" },\r\n  {\r\n    label: "禁用",\r\n    value: "0",\r\n    alias: "disabled",\r\n    color: "rgba(30, 41, 59, 0.25)",\r\n  },\r\n]);\r\n\r\nconst dict = {\r\n  menuType,\r\n  gender,\r\n  accountEnabledState,\r\n  roleEnabledState\r\n};\r\n\r\nexport default dict;\r\n\r\n```\r\n上面的代码并不复杂，首先我定义了一个叫 `createDict` 的工厂函数，然后在下面创建字典并导出，字典中的每一项都有`label`,`value`,`alias`,`color`四个属性，除了`color`其他三个都是必须的。\r\n\r\n## DictSelect\r\n使用字典的一种常用方式就是创建选择器，为此我创建了一个公共组件`DictSelect`，具体代码如下：\r\n```jsx\r\n// @/components/DictSelect\r\nimport { Select, Badge } from "antd";\r\nimport dict from "@/utils/dict";\r\n\r\nconst DictSelect = function (props) {\r\n  const { dictName, placeholder = "请选择", ...rest } = props;\r\n\r\n  const { options } = dict[dictName];\r\n\r\n  return (\r\n    <Select {...rest} options={options} placeholder={placeholder}>\r\n      {options.map((item) => (\r\n        <Select.Option key={item.value} value={item.value}>\r\n          {item.color ? (\r\n            <Badge color={item.color} text={item.label} />\r\n          ) : (\r\n            item.label\r\n          )}\r\n        </Select.Option>\r\n      ))}\r\n    </Select>\r\n  );\r\n};\r\nexport default DictSelect;\r\n\r\n```\r\n\r\n使用\r\n```jsx\r\nimport DictSelect from "@/components/DictSelect";\r\n\r\n<DictSelect dictName=\'gender\'/>\r\n```\r\n\r\n## 通过 `value` 获取 `label`\r\n在与后端的交互中，后端很可能会直接返回一个`value`，如：`const userinfo = {name: "张三", gender: "1"}`，我们需要将 `value` 转为 `lable` 进行展示，这时我们可以这样做：\r\n```jsx\r\nimport { Tag } from "antd";\r\nimport { gender as genderDict } from "@/utils/dict";\r\n\r\nexport default function UserInfo() {\r\n  const userinfo = { name: "张三", gender: "1" }; // 模拟的后端返回的数据\r\n  const map = genderDict.map[userinfo.gender];\r\n  const tag = {\r\n    color: map?.color || "rgba(0,0,0,.25)",\r\n    label: map?.label || "未知",\r\n  };\r\n  return (\r\n    <div>\r\n      <div>姓名：{userinfo.name}</div>\r\n      <div>性别：<Tag color={tag.color}>{tag.label}</Tag></div>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n## 使用 `alias` 消除魔法值\r\n在我们的代码中，很大可能会存在一些对字典 `value` 的逻辑判断，如：我们需要判断某个用户是男还是女，然后进行不同的逻辑，这时我们可以这样：\r\n```js\r\nimport { gender as genderDict } from "@/utils/dict";\r\n\r\nconst gender = "1"; // 模拟的后端返回的数据\r\n\r\nif (gender === genderDict.enum.male) {\r\n  // 如果是男\r\n} else if (gender === genderDict.enum.woman) {\r\n  // 如果是女\r\n} else {\r\n  // 未知\r\n}\r\n```\r\n\r\n## 为什么不在后端统一维护\r\n某些系统可能会在后端统一管理字典，在我看来那会出现以下几种问题：\r\n1. 只能通过一些规范来控制管理员的修改，一但修改就可能出现严重的bug。\r\n2. 需要很多代码来解决重复请求的问题。关于这个问题我写了一篇文章，有兴趣可以看一下：[前端数据字典的最优方案探索](https://juejin.cn/post/6949080259438313509)\r\n3. 难以消除魔法值。\r\n\r\n可能会有人说，你这样好麻烦，前端定义一份，后端也要定义一份，我的回答是：是的。必须在开发的时候就将字典定义好，一旦定义后绝对不允许单边修改。试想一种情况，假设我现在前端有如下代码：\r\n```js\r\nif (gender === 1) {\r\n  // 如果是男\r\n} else if (gender === 2) {\r\n  // 如果是女\r\n} else {\r\n  // 未知\r\n}\r\n```\r\n如果某一天某个后端同事说我觉得1男2女不太好，我要改成1女2男，这样代码就会走出错误的逻辑。所以我认为字典应该是属于前端与后端，后端与数据库之间的一个约定，是不能随意修改的，如果非要修改，那是一定要检测代码和更新数据库的，而上面的维护方式对于前端来说也非常便于修改。'}}]);
//# sourceMappingURL=917.e291e283.chunk.js.map